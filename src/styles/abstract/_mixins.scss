@use 'sass:map';

// LIST OF MIXINS:
//        screen
//        hocus
//        flex
//        square
//        padding
//        absoluteCenter

// BREAKPOINTS

$breakpoint-small: 600px;
$breakpoint-med-small: 960px;
$breakpoint-med: 1175px;

$breakpoints: (
  mobile: 0,
  tablet: 768px,
  desktop: 1024px
);

@mixin media($query) {
  @if $query == '>=desktop' {
    @media (min-width: map.get($breakpoints, desktop)) {
      @content;
    }
  }
  @else if $query == '>=tablet' {
    @media (min-width: map.get($breakpoints, tablet)) {
      @content;
    }
  }
  @else if $query == '<desktop' {
    @media (max-width: map.get($breakpoints, desktop)) {
      @content;
    }
  }
  // Ajoute d'autres cas si besoin
}

@mixin screen($size, $type: max, $pixels: $breakpoint-small) {
  @if $size == "small" {
    @media screen and ($type + -width: $breakpoint-small) {
      @content;
    }
  } @else if $size == "med-small" {
    @media screen and ($type + -width: $breakpoint-med-small) {
      @content;
    }
  } @else if $size == "med" {
    @media screen and ($type + -width: $breakpoint-med) {
      @content;
    }
  } @else if $size == "large" {
    @media screen and ($type + -width: $breakpoint-med) {
      @content;
    }
  } @else if $size == "custom" {
    @media screen and ($type + -width: $pixels + px) {
      @content;
    }
  } @else {
    @content;
  }
}

/*Media query mixin*/
@mixin hocus() {
  &:hover,
  &:focus {
    @content;
  }
}

@mixin flex($justify: center, $align: center, $direction: row) {
  display: -webkit-box; // old
  display: -moz-box; // old
  display: -ms-flexbox; // ie
  display: -webkit-flex; // new
  display: flex; // new

  @if $justify == center {
    justify-content: center;
  }

  @if $justify == space-between {
    justify-content: space-between;
  }

  @if $align == center {
    align-items: center;
  }
  @if $direction == column {
    flex-direction: column;
  }
}

@mixin square($size) {
  width: $size;
  height: $size;
}

@mixin beforeMixin($wdith, $height) {
  position: absolute;
  width: $wdith;
  height: $height;
  content: '';
}
//Padding mixin
@mixin padding($top, $right, $bottom, $left) {
  @if $top != 0 {
    padding-top: $top;
  }
  @if $right != 0 {
    padding-right: $right;
  }
  @if $bottom != 0 {
    padding-bottom: $bottom;
  }
  @if $left != 0 {
    padding-left: $left;
  }
}


@mixin absoluteCenter() {
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
}

/**
 * Mixin pour ajouter des bordures avec des pseudo-éléments
 * Crée une bordure en haut et/ou à gauche avec ::before et ::after
 * 
 * @param {string} $position - 'top-left' | 'top' | 'left' | 'top-bottom' | 'left-right'
 * @param {number} $width - Largeur du pseudo-élément horizontal (ex: 80%)
 * @param {number} $height - Hauteur du pseudo-élément vertical (ex: 80%)
 * @param {number} $thickness - Épaisseur de la bordure (ex: 2px)
 * @param {color} $color - Couleur de la bordure (défaut: $color-primary)
 */
@mixin cornerBorder(
  $position: 'top-left',
  $width: 80%,
  $height: 80%,
  $thickness: 2px,
  $color: $color-primary
) {
  position: relative;

  @if $position == 'top-left' or $position == 'top' or $position == 'top-bottom' {
    &::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: $width;
      height: $thickness;
      background-color: $color;
    }
  }

  @if $position == 'top-left' or $position == 'left' or $position == 'left-right' {
    &::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: $thickness;
      height: $height;
      background-color: $color;
    }
  }

  @if $position == 'top-bottom' {
    &::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      width: $width;
      height: $thickness;
      background-color: $color;
    }
  }

  @if $position == 'left-right' {
    &::after {
      content: '';
      position: absolute;
      top: 0;
      right: 0;
      width: $thickness;
      height: $height;
      background-color: $color;
    }
  }
}